# 认证机制详解

本文档详细说明系统的认证机制，包括 JWT Token 的生成、验证、使用和管理。

---

## 📋 目录

1. [认证概述](#认证概述)
2. [JWT Token 机制](#jwt-token-机制)
3. [认证流程](#认证流程)
4. [权限系统](#权限系统)
5. [开发环境 Mock Token](#开发环境-mock-token)
6. [Token 管理最佳实践](#token-管理最佳实践)
7. [常见问题](#常见问题)

---

## 认证概述

### 认证方式

系统使用 **JWT (JSON Web Token)** 进行用户认证：

- **标准**: JWT RFC 7519
- **算法**: HS256 (HMAC-SHA256)
- **签名密钥**: 通过 `JWT_SECRET` 环境变量配置
- **有效期**: 默认 7 天（可通过 `JWT_EXPIRES_IN` 配置）

### 认证架构

```
客户端                    后端服务
  |                          |
  |--- 1. POST /auth/login -->|
  |                          |
  |                          |-- 验证用户名密码
  |                          |-- 生成 JWT Token
  |<-- 2. 返回 Token ---------|
  |                          |
  |--- 3. API 请求 + Token -->|
  |     (Authorization:      |
  |      Bearer <token>)     |
  |                          |
  |                          |-- 验证 Token
  |                          |-- 查询用户信息
  |                          |-- 检查权限
  |<-- 4. 返回数据 -----------|
```

### 需要认证的接口

以下接口需要认证（携带 Token）：

- ✅ 仪表盘统计（所有接口）
- ✅ 任务管理（所有接口）
- ✅ 热搜管理（所有接口）
- ✅ 系统配置（大部分接口）
- ✅ AI 配置（所有接口）
- ✅ 用户管理（所有接口）
- ✅ 标签管理（所有接口）
- ✅ 备份管理（所有接口）
- ❌ 内容管理（当前所有接口均不需要认证）
- ❌ 认证模块（登录、注册等不需要认证）

> **注意**：部分接口的认证在代码中被注释掉了，需根据实际部署情况启用。

---

## JWT Token 机制

### Token 结构

JWT Token 由三部分组成，用 `.` 分隔：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6InV1aWQiLCJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNzM1NDQzMDAwLCJleHAiOjE3MzYwNDc4MDB9.signature
```

#### 1. Header（头部）
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### 2. Payload（负载）
```json
{
  "id": "uuid",
  "username": "admin",
  "role": "admin",
  "iat": 1735443000,
  "exp": 1736047800
}
```

**字段说明**：
- `id`: 用户 ID（UUID）
- `username`: 用户名
- `role`: 用户角色（`admin` 或 `operator`）
- `iat`: Token 签发时间（Unix 时间戳）
- `exp`: Token 过期时间（Unix 时间戳）

#### 3. Signature（签名）
使用 `JWT_SECRET` 对 Header 和 Payload 进行签名，确保 Token 未被篡改。

### Token 生成

**代码实现** ([backend/src/utils/jwt.js](../backend/src/utils/jwt.js))：

```javascript
const jwt = require('jsonwebtoken');

const generateToken = (user) => {
  const payload = {
    id: user.id,
    username: user.username,
    role: user.role
  };

  const options = {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d'
  };

  return jwt.sign(payload, process.env.JWT_SECRET, options);
};
```

**生成示例**：
```javascript
const user = {
  id: '550e8400-e29b-41d4-a716-446655440000',
  username: 'admin',
  role: 'admin'
};

const token = generateToken(user);
// 输出：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Token 验证

**代码实现**：
```javascript
const verifyToken = (token) => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return decoded;
  } catch (error) {
    console.error('Token verification failed:', error.message);
    return null;
  }
};
```

**验证流程**：
1. 验证签名是否正确（使用 `JWT_SECRET`）
2. 检查 Token 是否过期（`exp` 字段）
3. 返回解码后的 Payload

---

## 认证流程

### 1. 用户登录

**请求**：
```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "email": "admin@example.com",
  "password": "admin123"
}
```

**后端处理流程**：
```javascript
// 1. 验证用户名和密码
const user = await UserService.findByCredentials(email, password);

// 2. 检查用户是否激活
if (!user.is_active) {
  throw new Error('用户已禁用');
}

// 3. 生成 JWT Token
const token = generateToken(user);

// 4. 返回 Token 和用户信息
res.status(200).json({
  message: '登录成功',
  token,
  user: {
    id: user.id,
    username: user.username,
    email: user.email,
    role: user.role
  }
});
```

**成功响应**（200 OK）：
```json
{
  "message": "登录成功",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "username": "admin",
    "email": "admin@example.com",
    "role": "admin"
  }
}
```

**失败响应**：
```json
// 401 Unauthorized - 用户名或密码错误
{
  "message": "用户名或密码错误"
}

// 401 Unauthorized - 用户已禁用
{
  "message": "用户已被禁用"
}
```

### 2. 使用 Token 访问受保护接口

**请求头格式**：
```http
GET /api/v1/users/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**后端处理流程**（认证中间件）：
```javascript
const authenticate = async (req, res, next) => {
  // 1. 从请求头获取 Token
  const authHeader = req.header('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Unauthorized: No token provided' });
  }

  const token = authHeader.replace('Bearer ', '');

  // 2. 验证 Token
  const decoded = verifyToken(token);
  if (!decoded) {
    return res.status(401).json({ message: 'Unauthorized: Invalid token' });
  }

  // 3. 从数据库查询用户
  const user = await UserService.findUserById(decoded.id);
  if (!user || !user.is_active) {
    return res.status(401).json({ message: 'Unauthorized: User not found or inactive' });
  }

  // 4. 将用户信息附加到请求对象
  req.user = user;
  next();
};
```

### 3. 认证失败响应

| 状态码 | 错误信息 | 说明 |
|--------|----------|------|
| 401 | `Unauthorized: No token provided` | 请求头缺少 Token |
| 401 | `Unauthorized: Invalid token` | Token 无效或格式错误 |
| 401 | `Unauthorized: User not found or inactive` | 用户不存在或已禁用 |
| 401 | `Token已过期` | Token 已过期（需重新登录） |

---

## 权限系统

### 用户角色

系统支持两种角色：

| 角色 | 说明 | 权限 |
|------|------|------|
| `admin` | 管理员 | 拥有所有权限，包括用户管理、系统配置等 |
| `operator` | 操作员 | 普通用户权限，只能访问基础功能 |

### 权限控制

#### 1. 基于角色的授权

**代码实现**：
```javascript
const authorize = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
    }
    next();
  };
};
```

**使用示例**：
```javascript
// 仅管理员可访问
router.post('/users', authenticate, authorize(['admin']), UserController.createUser);

// 管理员和操作员都可访问
router.get('/content', authenticate, authorize(['admin', 'operator']), ContentController.getList);

// 所有认证用户都可访问
router.get('/dashboard', authenticate, DashboardController.getData);
```

#### 2. 管理员专用中间件

```javascript
const adminOnly = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ message: 'Forbidden: Admin access required' });
  }
  next();
};
```

**使用示例**：
```javascript
router.delete('/users/:id', authenticate, adminOnly, UserController.deleteUser);
```

### 权限矩阵

| 功能模块 | Operator | Admin |
|---------|----------|-------|
| 内容管理 | ✅ | ✅ |
| 仪表盘统计 | ✅ | ✅ |
| 任务管理 | ✅ | ✅ |
| 热搜查询 | ✅ | ✅ |
| 用户管理 | ❌ | ✅ |
| 系统配置 | ❌ | ✅ |
| AI 配置 | ❌ | ✅ |
| 备份管理 | ❌ | ✅ |

---

## 开发环境 Mock Token

为了方便开发调试，系统支持 Mock Token。

### 使用方法

使用 `mock-token-` 前缀的任意字符串作为 Token：

```bash
# Mock 管理员 Token
export TOKEN="mock-token-admin"

curl -X GET "http://localhost:3000/api/v1/users/me" \
  -H "Authorization: Bearer $TOKEN"
```

**响应**：
```json
{
  "id": "mock-user-id",
  "username": "mock-admin",
  "role": "admin",
  "is_active": true
}
```

### Mock Token 实现

**代码**：
```javascript
if (token.startsWith('mock-token-')) {
  const mockUser = {
    id: 'mock-user-id',
    username: 'mock-admin',
    role: 'admin',
    is_active: true
  };

  req.user = mockUser;
  return next();
}
```

### 注意事项

⚠️ **警告**：
- Mock Token 仅在开发环境（`NODE_ENV=development`）有效
- 生产环境不支持 Mock Token
- 部署前确保移除或禁用 Mock Token 功能

---

## Token 管理最佳实践

### 1. Token 存储

#### Android (Kotlin)
```kotlin
// 使用 SharedPreferences 存储 Token
val sharedPrefs = getSharedPreferences("auth", Context.MODE_PRIVATE)

// 保存 Token
sharedPrefs.edit()
    .putString("token", token)
    .apply()

// 读取 Token
val token = sharedPrefs.getString("token", null)
```

#### React (JavaScript)
```javascript
// 使用 localStorage 存储 Token
localStorage.setItem('token', token);

// 读取 Token
const token = localStorage.getItem('token');

// 删除 Token
localStorage.removeItem('token');
```

#### iOS (Swift)
```swift
// 使用 UserDefaults 存储 Token
UserDefaults.standard.set(token, forKey: "token")

// 读取 Token
let token = UserDefaults.standard.string(forKey: "token")

// 删除 Token
UserDefaults.standard.removeObject(forKey: "token")
```

### 2. Token 注入

#### 统一请求拦截器

**Kotlin (OkHttp)**：
```kotlin
class AuthInterceptor(private val tokenProvider: TokenProvider) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
            .addHeader("Authorization", "Bearer ${tokenProvider.getToken()}")
            .build()
        return chain.proceed(request)
    }
}
```

**JavaScript (Axios)**：
```javascript
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

**Swift (Alamofire）**：
```swift
class AuthInterceptor: RequestInterceptor {
    func adapt(_ urlRequest: URLRequest, for session: Session, completion: @escaping (URLRequest) -> Void) {
        var request = urlRequest
        if let token = UserDefaults.standard.string(forKey: "token") {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        completion(request)
    }
}
```

### 3. Token 过期处理

#### 响应拦截器

**JavaScript (Axios)**：
```javascript
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Token 过期，清除本地存储
      localStorage.removeItem('token');
      localStorage.removeItem('user');

      // 跳转到登录页
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### 4. Token 刷新策略

当前系统不支持 Token 刷新，Token 过期后需重新登录。

**建议实现**（可选）：
1. 实现短期 Access Token（1小时）+ 长期 Refresh Token（30天）
2. Access Token 过期时使用 Refresh Token 获取新的 Access Token
3. Refresh Token 也过期时才需要重新登录

---

## 常见问题

### Q1: Token 有效期是多久？

**A**: 默认 7 天，可通过 `.env` 文件中的 `JWT_EXPIRES_IN` 配置。

```env
JWT_EXPIRES_IN=7d       # 7天
JWT_EXPIRES_IN=24h      # 24小时
JWT_EXPIRES_IN=30m      # 30分钟
```

### Q2: 如何修改 Token 密钥？

**A**: 修改 `.env` 文件中的 `JWT_SECRET`：

```env
JWT_SECRET=your-super-secret-key-change-this-in-production
```

⚠️ **注意**：
- 修改密钥后所有现有 Token 将失效
- 用户需要重新登录
- 生产环境使用强随机密钥

### Q3: Token 存储在客户端安全吗？

**A**:
- ✅ 使用 HTTPS 传输加密
- ✅ Token 有过期时间限制
- ⚠️ XSS 攻击风险（localStorage）
- ✅ 更安全的方式：使用 HttpOnly Cookie（需后端支持）

### Q4: 如何撤销 Token？

**A**: 当前系统不支持主动撤销 Token。解决方案：
1. 短期 Token 有效期（如1小时）
2. 实现 Token 黑名单（Redis）
3. 禁用用户账号（下次请求时拒绝）

### Q5: 为什么有些接口不需要认证？

**A**:
- 登录、注册等接口本身不需要 Token
- 内容管理接口的认证在代码中被注释掉了
- 可根据安全需求在 [backend/src/routes/](../backend/src/routes/) 中启用认证

```javascript
// 取消注释以启用认证
const { authenticate } = require('../middleware/auth');
router.use(authenticate);
```

### Q6: 如何实现"记住我"功能？

**A**: 实现长期 Token：
1. 勾选"记住我"时签发 30 天 Token
2. 未勾选时签发 1 天 Token
3. 后端根据登录请求参数决定有效期

---

## 相关文档

- [快速开始指南](./01_快速开始.md)
- [错误处理与状态码](./03_错误处理与状态码.md)
- [用户管理模块](./modules/08_用户管理.md)

---

**最后更新**: 2025-12-28
